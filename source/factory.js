import { objectDefineProperties } from './utilites';

import adapters, { adapter, valueAdapter } from './adapters/index';
import {
  customGenerator,
  emptyGenerator,
  expandGenerator,
  randomGenerator,
  rangeGenerator,
  repeatGenerator
} from './generators/index';
import listeners, { listener } from './listeners/index';
import notifiers from './notifiers/index';
import instance, { operators } from './instance';

const empty = instance(emptyGenerator(true));

/**
Creates new instance emitting values extracted from every provided data source in series.
If no data sources provided, creates empty instance emitting "done" event only.

@alias aeroflow

@param {any} [sources]
Data sources to extract values from.

@return {Flow}

@property {Adapters} adapters
Mixed array/map of adapters for various types of data sources.
As a map matches the type of a data source to adapter function (e.g. Promise -> promiseAdapter).
As an array contains functions performing arbitrary (more complex than type matching) testing
of a data source (e.g. some iterable -> iterableAdapter).
When aeroflow adapts particular data source, direct type mapping is attempted first.
Then, if mapping attempt did not return an adapter function,
array is enumerated in reverse order, from last indexed adapter to first,
until a function is returned.
This returned function is used as adapter and called with single argument: the data source being adapted.
Expected that adapter function being called with data source returns an emitter function accepting 2 arguments:
next callback, done callback and execution context.
If no adapter function has been found, the data source is treated as scalar value and emitted as is.
See examples to find out how to create and register custom adapters.

@property {object} operators
Map of operators available for use with every instance.
See examples to find out how to create and register custom operators.

@example
aeroflow().notify(console).run();
// done true
aeroflow(
  1,
  [2, 3],
  new Set([4, 5]),
  () => 6,
  Promise.resolve(7),
  new Promise(resolve => setTimeout(() => resolve(8), 500))
).notify(console).run();
// next 1
// next 2
// next 3
// next 4
// next 5
// next 6
// next 7
// next 8 // after 500ms
// done true
aeroflow(new Error('test')).notify(console).run();
// done Error: test(…)
// Uncaught (in promise) Error: test(…)
aeroflow(() => { throw new Error }).notify(console).run();
// done Error: test(…)
// Uncaught (in promise) Error: test(…)
aeroflow("test").notify(console).run();
// next test
// done true
aeroflow.adapters.use('String', aeroflow.adapters['Array']);
aeroflow("test").notify(console).run();
// next t
// next e
// next s
// next t
// done true
aeroflow.operators.test = function() {
  return this.chain(emitter => (next, done, context) => emitter(
    value => next('test:' + value),
    done,
    context));
}
aeroflow(42).test().notify(console).run();
// next test:42
// done true
*/
export default function aeroflow(...sources) {
  return sources.length
    ? instance(adapter(sources))
    : empty;
}

/**
Creates programmatically controlled instance.

@memberof aeroflow
@static

@param {function|any} emitter
The emitter function taking three arguments:
next - the function emitting 'next' event,
done - the function emitting 'done' event,
context - the execution context.

@return {Flow}
The new instance emitting values generated by emitter function.

@example
aeroflow.create((next, done, context) => {
  next('test');
  done();
}).notify(console).run();
// next test
// done true
aeroflow.create((next, done, context) => {
  window.addEventListener('click', next);
  return () => window.removeEventListener('click', next);
}).take(2).notify(console).run();
// next MouseEvent {...}
// next MouseEvent {...}
// done false
*/
function create(emitter) {
  return instance(customGenerator(emitter));
}

/**
@alias aeroflow.expand

@param {function} expander
@param {any} [seed]

@return {Flow}

@example
aeroflow.expand(value => value * 2, 1).take(3).notify(console).run();
// next 2
// next 4
// next 8
// done false
*/
function expand(expander, seed) {
  return instance(expandGenerator(expander, seed));
}

/**
Returns new instance emitting the provided source as is.

@alias aeroflow.just

@param {any} source
The source to emit as is.

@return {Flow}
The new instance emitting provided value.

@example
aeroflow.just([1, 2, 3]).notify(console).run();
// next [1, 2, 3]
// done
*/
// TODO: multiple arguments
function just(source) {
  return instance(valueAdapter(source));
}

/**
@alias aeroflow.listen

@example
aeroflow
  .listen(document, 'mousemove')
  .map(event => ({ x: event.x, y: event.y }))
  .take(3)
  .notify(console)
  .run();
// next Object {x: 241, y: 269}
// next Object {x: 221, y: 272}
// next Object {x: 200, y: 273}
// done false
*/
function listen(source, ...parameters) {
  return instance(listener(source, parameters));
}

/**
Creates new instance emitting infinite sequence of random numbers.

@alias aeroflow.random

@param {number} [minimum]
@param {number} [maximum]

@return {Flow}
The new instance emitting random numbers.

@example
aeroflow.random().take(2).notify(console).run();
// next 0.07417976693250232
// next 0.5904422281309957
// done false
aeroflow.random(1, 9).take(2).notify(console).run();
// next 7
// next 2
// done false
aeroflow.random(1.1, 8.9).take(2).notify(console).run();
// next 4.398837305698544
// next 2.287970747705549
// done false
*/
function random(minimum, maximum) {
  return instance(randomGenerator(minimum, maximum));
}

/**
@alias aeroflow.range

@param {number} [start]
@param {number} [end]
@param {number} [step]

@return {Flow}

@example
aeroflow.range().take(3).notify(console).run();
// next 0
// next 1
// next 2
// done false
aeroflow.range(-3).take(3).notify(console).run();
// next -3
// next -2
// next -1
// done false
aeroflow.range(1, 1).notify(console).run();
// next 1
// done true
aeroflow.range(0, 5, 2).notify(console).run();
// next 0
// next 2
// next 4
// done true
aeroflow.range(5, 0, -2).notify(console).run();
// next 5
// next 3
// next 1
// done true
*/
function range(start, end, step) {
  return instance(rangeGenerator(start, end, step));
}

/**
Creates infinite flow, repeating static/dynamic value immediately or with static/dynamic delay.

@alias aeroflow.repeat

@param {function|any} [repeater]
Optional static value to repeat;
or function providing dynamic value and called with one argument:
1) index of current iteration.
@param {function|number} [delayer]
Optional static delay between iterations in milliseconds;
or function providing dynamic delay and called with one argument:
1) index of current iteration.

@return {Flow}
New flow emitting repeated values.

@example
aeroflow.repeat(Math.random()).take(2).notify(console).run();
// next 0.7492001398932189
// next 0.7492001398932189
// done false
aeroflow.repeat(() => Math.random()).take(2).notify(console).run();
// next 0.46067174314521253
// next 0.7977648684754968
// done false
aeroflow.repeat(index => Math.pow(2, index)).take(3).notify(console).run();
// next 1
// next 2
// next 4
// done false
aeroflow.repeat('ping', 500).take(3).notify(console).run();
// next ping // after 500ms
// next ping // after 500ms
// next ping // after 500ms
// done false
aeroflow.repeat(index => index, index => 500 + 500 * index).take(3).notify(console).run();
// next 0 // after 500ms
// next 1 // after 1000ms
// next 2 // after 1500ms
// done false
*/
function repeat(repeater, delayer) {
  return instance(repeatGenerator(repeater, delayer));
}

function defineGenerator(defintion, generator) {
  defintion[generator.name] = { value: generator };
  return defintion;
}

objectDefineProperties(aeroflow, [
  create,
  expand,
  just,
  listen,
  random,
  range,
  repeat
].reduce(defineGenerator, {}));

objectDefineProperties(aeroflow, {
  adapters: { value: adapters },
  empty: { enumerable: true, get: () => empty },
  listeners: { value: listeners },
  notifiers: { value: notifiers },
  operators: { value: operators }
});
